name: Build and Deploy to GKE

on:
  workflow_dispatch:
  push:
    branches: [ "dev", "hml", "main" ]

env:
  # Deploy env
  PROJECT_ID: ${{ vars.GCP_PROJECT_ID }}
  NAMESPACE: ${{ vars.NAMESPACE }}
  APP_NAME: ${{ vars.APP_NAME }}
  APP_DOMAIN: ${{ vars.APP_DOMAIN }}
  DEPLOYMENT: ${{ vars.ENV_NAME }}-${{ vars.NAMESPACE }}-${{ vars.APP_NAME }}
  ENV_NAME: ${{ vars.ENV_NAME }}
  GCP_CREDENTIALS: ${{ vars.GCP_CREDENTIALS }}
  GKE_CLUSTER: ${{ vars.GKE_CLUSTER }}
  GKE_ZONE: ${{ vars.GKE_ZONE }}
  REGISTRY_DOMAIN: ${{ vars.REGISTRY_DOMAIN }}
  REPOSITORY: ${{ vars.NAMESPACE }}
  CONTAINER_NAME: ${{ vars.CONTAINER_NAME }}
  IMAGE_TAG: ${{ github.sha }}
  # App env
  SECRET_KEY: ${{ vars.SECRET_KEY }}
  DEBUG: False
  APP_URL: ${{ vars.APP_URL }}
  CSRF_URL: https://${{ vars.APP_URL }}
  LOG_LEVEL: ${{ vars.LOG_LEVEL }}
  DB_ENGINE: ${{ vars.DB_ENGINE }}
  DB_HOST: ${{ vars.DB_HOST }}
  DB_PORT: ${{ vars.DB_PORT }}
  DB_NAME: ${{ vars.DB_NAME }}
  DB_USER: ${{ vars.DB_USERNAME }}
  DB_PASS: '${{ vars.DB_PASSWORD }}'
  SENTRY_DSN: ${{ vars.SENTRY_DSN }}
  PAGARME_TOKEN: '${{ vars.PAGARME_TOKEN }}'
  PAGARME_LONGVIEW_RECIPIENT: ${{ vars.PAGARME_LONGVIEW_RECIPIENT }}
  PAGARME_URL: 'https://api.pagar.me/core/v5'
  CORREIOS_AUTHORIZATION: ${{ vars.CORREIOS_AUTHORIZATION }}
  CORREIOS_NUMERO_CONTRATO: ${{ vars.CORREIOS_NUMERO_CONTRATO }}
  MAIL_TIMEOUT: ${{ vars.MAIL_TIMEOUT }}
  MAIL_HOST: ${{ vars.MAIL_HOST }}
  MAIL_PORT: ${{ vars.MAIL_PORT }}
  MAIL_USERNAME: ${{ vars.MAIL_USERNAME }}
  MAIL_PASSWORD: ${{ vars.MAIL_PASSWORD }}
  MAIL_FROM_NAME: ${{ vars.MAIL_FROM_NAME }}
  LOG_EMAIL_HOST: ${{ vars.LOG_EMAIL_HOST }}
  LOG_EMAIL_PORT: ${{ vars.LOG_EMAIL_PORT }}
  LOG_EMAIL_HOST_USER: ${{ vars.LOG_EMAIL_HOST_USER }}
  LOG_EMAIL_HOST_PASSWORD: '${{ vars.LOG_EMAIL_HOST_PASSWORD }}'

jobs:

  prepare-envs:
    name: Prepare envs
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.ref_name }}
    outputs:
      image: ${{env.REGISTRY_DOMAIN}}/${{env.PROJECT_ID}}/${{env.REPOSITORY}}/${{ vars.NAMESPACE }}-${{env.APP_NAME}}-${{vars.ENV_NAME}}
    steps:
    - name: Echo output
      run: |
        echo ${{env.REGISTRY_DOMAIN}}/${{env.PROJECT_ID}}/${{env.REPOSITORY}}/${{ vars.NAMESPACE }}-${{env.APP_NAME}}-${{vars.ENV_NAME}}

  ##### Actions Template code in organization
  setup-build:
    name: Setup, Build
    needs: [prepare-envs]
    runs-on: ['self-hosted', 'python']
    environment:
      name: ${{ github.ref_name }}

    permissions:
      contents: 'read'
      id-token: 'write'

    steps:
    - name: Set env vars helper
      run: |
        echo "ENV_NAME=${{ vars.ENV_NAME }}" >> $GITHUB_ENV
        echo "DEPLOYMENT=${{ vars.ENV_NAME }}-${{ vars.NAMESPACE }}-${{ env.APP_NAME }}" >> $GITHUB_ENV
        echo "IMAGE=${{ needs.prepare-envs.outputs.image }}" >> $GITHUB_ENV
        echo "IMAGE_TAG=${{ env.IMAGE_TAG }}" >> $GITHUB_ENV
        echo "CONTAINER_NAME=${{ env.CONTAINER_NAME }}" >> $GITHUB_ENV
        # echo "APP_URL=${{ vars.APP_URL }}" >> $GITHUB_ENV

    - name: Checkout
      uses: actions/checkout@v3

    # Configure Workload Identity Federation and generate an access token.
    - id: 'auth'
      uses: 'google-github-actions/auth@v1'
      with:
        token_format: 'access_token'
        credentials_json: '${{ env.GCP_CREDENTIALS }}'

    # Get the GKE credentials so we can deploy to the cluster
    - name: Set up GKE credentials
      uses: google-github-actions/get-gke-credentials@v1
      with:
        cluster_name: ${{ env.GKE_CLUSTER }}
        location: ${{ env.GKE_ZONE }}
        project_id: ${{ env.PROJECT_ID }}
        use_internal_ip: false
        use_auth_provider: false

    - name: Docker configuration
      run: |-
        echo ${{steps.auth.outputs.access_token}} | docker login -u oauth2accesstoken --password-stdin https://${{ env.REGISTRY_DOMAIN }}

    - name: Parse ENV FILE
      uses: nowactions/envsubst@v1
      with:
        input: .env.k8s
        output: .env

    # Build the Docker image
    - name: Build
      run: |-
        docker build . \
          --tag "${{ env.IMAGE }}:latest" \
          --tag "${{ env.IMAGE }}:${{ env.IMAGE_TAG }}" \
          --build-arg GITHUB_SHA="${{ github.sha }}" \
          --build-arg GITHUB_REF="${{ github.ref }}"

    # Push the Docker image to Google Artifact Registry
    - name: Push Image
      run: |
        docker push "${{ env.IMAGE }}:latest"
        docker push "${{ env.IMAGE }}:${{ env.IMAGE_TAG }}"

  ###### Actions Custom steps
  database:
    name: Database, Test and Scripts
    runs-on: ['self-hosted', 'default']
    needs: [prepare-envs, setup-build]
    container:
      image: ${{ needs.prepare-envs.outputs.image }}:latest
      credentials:
         username: _json_key
         password: ${{ vars.GCP_CREDENTIALS }}
    environment:
      name: ${{ github.ref_name }}
    defaults:
      run:
        working-directory: /src/

    steps:
    - name: Migrate
      run: python manage.py migrate --noinput
    #- name: Test
    #  run: python manage.py test
    #- name: Load Banks
    #  run: python manage.py runscript load_banks

  ###### Actions Template deploy final steps
  deploy:
    name: Publish and Deploy
    runs-on: ['self-hosted', 'python']
    needs: [prepare-envs, database]
    environment:
      name: ${{ github.ref_name }}

    permissions:
      contents: 'read'
      id-token: 'write'

    steps:
    - name: Checkout
      uses: actions/checkout@v3

    - name: Install kubectl
      uses: azure/setup-kubectl@v3

    # Configure Workload Identity Federation and generate an access token.
    - id: 'auth'
      uses: 'google-github-actions/auth@v1'
      with:
        token_format: 'access_token'
        credentials_json: '${{ env.GCP_CREDENTIALS }}'

    # Get the GKE credentials so we can deploy to the cluster
    - name: Set up GKE credentials
      uses: google-github-actions/get-gke-credentials@v1
      with:
        cluster_name: ${{ env.GKE_CLUSTER }}
        location: ${{ env.GKE_ZONE }}
        project_id: ${{ env.PROJECT_ID }}
        use_internal_ip: false
        use_auth_provider: false

    - name: Parse SETUP YAML
      uses: nowactions/envsubst@v1
      with:
        input: ./k8s/setup.yml
        output: ./output.yml

    - name: Parse DEPLOY YAML
      uses: nowactions/envsubst@v1
      with:
        input: ./k8s/ambiente.yml
        output: ./deploy.yml
      env:
        IMAGE: ${{ needs.prepare-envs.outputs.image }}

    # Deploy
    - name: Setup
      run: |
        cat output.yml
        kubectl apply -f output.yml

    - name: Deploy
      run: |
        cat deploy.yml
        kubectl apply -f deploy.yml
